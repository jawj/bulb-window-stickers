// Generated by CoffeeScript 1.12.2
var slice = [].slice,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  hasProp = {}.hasOwnProperty,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

this.extend = function() {
  var dest, j, k, len1, src, srcs, v;
  dest = arguments[0], srcs = 2 <= arguments.length ? slice.call(arguments, 1) : [];
  for (j = 0, len1 = srcs.length; j < len1; j++) {
    src = srcs[j];
    for (k in src) {
      v = src[k];
      dest[k] = v;
    }
  }
  return dest;
};

this.w = function(str) {
  return str.split(/\s+/);
};

this.b64 = function(input, output) {
  var chars, chr1, chr2, chr3, i, len, padLen, padded;
  if (output == null) {
    output = '';
  }
  chars = b64.chars;
  len = input.length;
  padLen = (3 - len % 3) % 3;
  padded = padLen === 0 ? input : input + '\x00\x00'.substring(0, padLen);
  i = 0;
  while (i < len) {
    chr1 = padded.charCodeAt(i++) & 255;
    chr2 = padded.charCodeAt(i++) & 255;
    chr3 = padded.charCodeAt(i++) & 255;
    output += chars[chr1 >> 2];
    output += chars[((chr1 & 3) << 4) | (chr2 >> 4)];
    output += chars[((chr2 & 15) << 2) | (chr3 >> 6)];
    output += chars[chr3 & 63];
  }
  if (padLen === 0) {
    return output;
  } else {
    return output.substring(0, output.length - padLen) + '=='.substring(0, padLen);
  }
};

b64.chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split('');

this.cls = function(el, opts) {
  var addClasses, c, classHash, classes, hasClasses, j, k, l, len1, len2, len3, len4, len5, m, o, p, ref, ref1, ref2, ref3, removeClasses, toggleClasses;
  if (opts == null) {
    opts = {};
  }
  classHash = {};
  classes = el.className.match(cls.re);
  if (classes != null) {
    for (j = 0, len1 = classes.length; j < len1; j++) {
      c = classes[j];
      classHash[c] = true;
    }
  }
  hasClasses = (ref = opts.has) != null ? ref.match(cls.re) : void 0;
  if (hasClasses != null) {
    for (l = 0, len2 = hasClasses.length; l < len2; l++) {
      c = hasClasses[l];
      if (!classHash[c]) {
        return false;
      }
    }
    return true;
  }
  addClasses = (ref1 = opts.add) != null ? ref1.match(cls.re) : void 0;
  if (addClasses != null) {
    for (m = 0, len3 = addClasses.length; m < len3; m++) {
      c = addClasses[m];
      classHash[c] = true;
    }
  }
  removeClasses = (ref2 = opts.remove) != null ? ref2.match(cls.re) : void 0;
  if (removeClasses != null) {
    for (o = 0, len4 = removeClasses.length; o < len4; o++) {
      c = removeClasses[o];
      delete classHash[c];
    }
  }
  toggleClasses = (ref3 = opts.toggle) != null ? ref3.match(cls.re) : void 0;
  if (toggleClasses != null) {
    for (p = 0, len5 = toggleClasses.length; p < len5; p++) {
      c = toggleClasses[p];
      if (classHash[c]) {
        delete classHash[c];
      } else {
        classHash[c] = true;
      }
    }
  }
  el.className = ((function() {
    var results;
    results = [];
    for (k in classHash) {
      results.push(k);
    }
    return results;
  })()).join(' ');
  return null;
};

cls.re = /\S+/g;

this.get = function(opts) {
  var el, els, hasCls, inside, ref, ref1, ref2, ref3, tag;
  if (opts == null) {
    opts = {};
  }
  inside = (ref = opts.inside) != null ? ref : document;
  tag = (ref1 = opts.tag) != null ? ref1 : '*';
  if (opts.id != null) {
    return inside.getElementById(opts.id);
  }
  hasCls = opts.cls != null;
  if (hasCls && tag === '*' && (inside.getElementsByClassName != null)) {
    return inside.getElementsByClassName(opts.cls);
  }
  els = inside.getElementsByTagName(tag);
  if (hasCls) {
    els = (function() {
      var j, len1, results;
      results = [];
      for (j = 0, len1 = els.length; j < len1; j++) {
        el = els[j];
        if (cls(el, {
          has: opts.cls
        })) {
          results.push(el);
        }
      }
      return results;
    })();
  }
  if ((opts.multi == null) && (ref2 = tag.toLowerCase(), indexOf.call(get.uniqueTags, ref2) >= 0)) {
    return (ref3 = els[0]) != null ? ref3 : null;
  } else {
    return els;
  }
};

get.uniqueTags = 'html body frameset head title base'.split(' ');

this.text = function(t) {
  return document.createTextNode('' + t);
};

this.make = function(opts) {
  var c, j, k, len1, ref, t, v;
  if (opts == null) {
    opts = {};
  }
  t = document.createElement((ref = opts.tag) != null ? ref : 'div');
  for (k in opts) {
    if (!hasProp.call(opts, k)) continue;
    v = opts[k];
    switch (k) {
      case 'tag':
        continue;
      case 'parent':
        v.appendChild(t);
        break;
      case 'kids':
        for (j = 0, len1 = v.length; j < len1; j++) {
          c = v[j];
          if (c != null) {
            t.appendChild(c);
          }
        }
        break;
      case 'prevSib':
        v.parentNode.insertBefore(t, v.nextSibling);
        break;
      case 'text':
        t.appendChild(text(v));
        break;
      case 'cls':
        t.className = v;
        break;
      default:
        t[k] = v;
    }
  }
  return t;
};

this.xhr = function(opts) {
  var k, method, ref, ref1, req, v;
  if (opts == null) {
    opts = {};
  }
  method = (ref = opts.method) != null ? ref : 'GET';
  req = new XMLHttpRequest();
  req.onreadystatechange = function() {
    if (req.readyState === 4 && (req.status === 200 || !location.href.match(/^https?:/))) {
      return opts.success(req);
    }
  };
  if (opts.mime != null) {
    req.overrideMimeType(opts.mime);
  }
  if (opts.user != null) {
    req.user = opts.user;
  }
  if (opts.password != null) {
    req.password = opts.password;
  }
  if (opts.headers != null) {
    ref1 = opts.headers;
    for (k in ref1) {
      v = ref1[k];
      req.setRequestHeader(k, v);
    }
  }
  req.open(method, opts.url);
  if (opts.type === 'binString') {
    req.overrideMimeType('text/plain; charset=x-user-defined');
  } else if (opts.type != null) {
    req.responseType = opts.type;
  }
  req.send(opts.data);
  return true;
};

this.noop = function(x) {
  return x;
};

this.jsonp = function(opts) {
  var callbackName, ref, ref1, url;
  callbackName = (ref = opts.callback) != null ? ref : '_JSONPCallback_' + jsonp.callbackNum++;
  url = opts.url.replace('<cb>', callbackName);
  window[callbackName] = (ref1 = opts.success) != null ? ref1 : noop;
  return make({
    tag: 'script',
    src: url,
    parent: get({
      tag: 'head'
    })
  });
};

jsonp.callbackNum = 0;

this.ParallelWaiter = (function() {
  function ParallelWaiter(waitingFor, cb) {
    this.waitingFor = waitingFor;
    this.cb = cb;
    this.returnValues = {};
  }

  ParallelWaiter.prototype.await = function(n) {
    if (n == null) {
      n = 1;
    }
    return this.waitingFor += n;
  };

  ParallelWaiter.prototype.done = function(returnValues) {
    var k, v;
    for (k in returnValues) {
      v = returnValues[k];
      this.returnValues[k] = v;
    }
    if (--this.waitingFor === 0) {
      return this.cb(this.returnValues);
    }
  };

  return ParallelWaiter;

})();

this.BinReader = (function() {
  function BinReader(data) {
    this.data = data;
    this.offset = 0;
  }

  BinReader.prototype.skip = function(n) {
    this.offset += n;
    return this;
  };

  BinReader.prototype.seek = function(n) {
    this.offset = n;
    return this;
  };

  BinReader.prototype.binString = function(n, str) {
    var end, i, j, ref;
    if (n == null) {
      n = 2e308;
    }
    if (str == null) {
      str = '';
    }
    end = Math.min(n, this.data.length - this.offset);
    for (i = j = 0, ref = end; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      str += String.fromCharCode(this.uchar());
    }
    return str;
  };

  BinReader.prototype.uint16be = function() {
    return (this.uchar() << 8) + this.uchar();
  };

  BinReader.prototype.uint32be = function() {
    return (this.uint16be() << 16) + this.uint16be();
  };

  BinReader.prototype.eof = function() {
    return this.offset >= this.data.length;
  };

  return BinReader;

})();

this.BinStringReader = (function(superClass) {
  extend(BinStringReader, superClass);

  function BinStringReader() {
    return BinStringReader.__super__.constructor.apply(this, arguments);
  }

  BinStringReader.prototype.uchar = function() {
    return this.data.charCodeAt(this.offset++) & 0xff;
  };

  return BinStringReader;

})(BinReader);

this.Uint8ArrayReader = (function(superClass) {
  extend(Uint8ArrayReader, superClass);

  function Uint8ArrayReader() {
    return Uint8ArrayReader.__super__.constructor.apply(this, arguments);
  }

  Uint8ArrayReader.prototype.uchar = function() {
    return this.data[this.offset++];
  };

  Uint8ArrayReader.prototype.subarray = function(n) {
    return this.data.subarray(this.offset, (this.offset += n));
  };

  return Uint8ArrayReader;

})(BinReader);

//# sourceMappingURL=affogato.js.map
